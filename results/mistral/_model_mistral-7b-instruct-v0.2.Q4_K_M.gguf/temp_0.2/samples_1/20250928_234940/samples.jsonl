{"task_id": "HumanEval/0", "completion": "from typing import List, Float\n\ndef has_close_elements(numbers: List[Float], threshold: Float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    \"\"\"\n    return len({abs(x - y) for x, y in itertools.combinations(numbers, 2) if abs(x - y) < threshold}) > 0"}
{"task_id": "HumanEval/1", "completion": " import re\n\n                     def separate_paren_groups(paren_string: str) -> List[str]:\n                         pattern = r'\\(([^()]*)\\)'\n                         matches = re.findall(pattern, paren_string)\n                         return [match[0] for match in matches]"}
{"task_id": "HumanEval/2", "completion": "\n                    def truncate_number(number: float) -> float:\n                        return number % 1\n\n                    # Alternative solution using math module\n                    # def truncate_number(number: float) -> float:\n                    #     return number - int(number)"}
{"task_id": "HumanEval/3", "completion": "from typing import List\n\ndef below_zero(operations: List[int]):\n    \"\"\" You're given a list of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n    at that point function should return True. Otherwise it should return False.\n    \"\"\"\n    current_balance = 0\n    for operation in operations:\n        current_balance += operation\n        if current_balance < 0:\n            return True\n    return False"}
{"task_id": "HumanEval/4", "completion": "from typing import List\n\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n        around the mean of this dataset.\n        Mean Absolute Deviation is the average absolute difference between each\n                 element and a centerpoint (mean in this case):\n                 MAD = average | x - x_mean |\n    \"\"\"\n    if not numbers:\n        raise ValueError(\"Input list cannot be empty\")\n\n    mean = sum(numbers) / len(numbers)\n    return sum(abs(x - mean) for x in numbers) / len(numbers)"}
{"task_id": "HumanEval/5", "completion": "from typing import List\n\ndef intersperse(numbers: List[int], delimeter: int) -> List[int]:\n    result = []\n    for i in range(len(numbers)):\n        if i % 2 == 0:\n            result.append(numbers[i])\n        else:\n            result.append(delimeter)\n            result.append(numbers[i])\n    return result"}
{"task_id": "HumanEval/6", "completion": " import re\n                     from typing import List\n\n                     def parse_nested_parens(paren_string: str) -> List[int]:\n                         \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n                         For each of the group, output the deepest level of nesting of parentheses.\n                         E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n                         >>> parse_nested_parens('(()()) ((())) () ((())()())')\n                         [2, 3, 1, 3]\n                         \"\"\"\n                         stack = []\n                         result = []\n                         pattern = r'\\(([^()]*)\\)'\n                         match = re.findall(pattern, paren_string)\n                         for group in match:\n                             level = len(group) // 2\n                             result.append(level)\n                             while level > 0:\n                                 stack.append(level)\n                                 level -= 1\n                         while stack:\n                             level = stack.pop()\n                            "}
{"task_id": "HumanEval/7", "completion": "from typing import List\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\"\n    return [s for s in strings if substring in s]"}
{"task_id": "HumanEval/8", "completion": "from typing import List, Tuple\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    if not numbers:\n        return (0, 1)\n\n    sum = 0\n    product = 1\n    for number in numbers:\n        sum += number\n        product *= number\n\n    return (sum, product)"}
{"task_id": "HumanEval/9", "completion": "from typing import List, Tuple\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    if not numbers:\n        return []\n\n    result = [numbers[0]]\n    for num in numbers[1:]:\n        result.append(max(num, result[-1]))\n\n    return result"}
{"task_id": "HumanEval/10", "completion": "def is_palindrome(string: str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\n\ndef make_palindrome(string: str) -> str:\n    def is_palindromic_substring(s):\n        start = 0\n        length = len(s)\n        while start < length:\n            end = length - 1\n            while end > start and s[start] != s[end]:\n                start += 1\n                end -= 1\n            if start >= end:\n                return s[start:]\n            start += 1\n        return \"\"\n\n    palindromic_substring = is_palindromic_substring(string)\n    if len(palindromic_substring) == 0:\n        return string + string[:len(string)//2]\n    else:\n        return string + palindromic_substring[::-1]"}
{"task_id": "HumanEval/11", "completion": " def xor_bitwise(a, b):\n                        return ''.join(map(lambda x, y: str(int(x) ^ int(y))), zip(a[::-1], b[::-1]))\n\n                    def string_xor(a: str, b: str):\n                        if len(a) != len(b):\n                            raise ValueError(\"Strings must be of equal length\")\n                        return xor_bitwise(a, b)\n\n                    from typing import List\n\n                    def string_xor(a: List[str], b: List[str]) -> List[str]:\n                        if len(a) != len(b):\n                            raise ValueError(\"Lists must be of equal length\")\n                        return [xor_bitwise(i, j) for i, j in zip(a, b)]\n\n                    def xor_bitwise(a, b):\n                        return ''.join(map(lambda x, y: str(int(x) ^ int(y)), list(map(ord, [a[::-1], b[::-"}
{"task_id": "HumanEval/12", "completion": "from typing import List, Optional\n\ndef longest(strings: List[str]) -> Optional[str]:\n    if not strings:\n        return None\n    max_length = max([len(s) for s in strings])\n    return next((string for string in strings if len(string) == max_length), '')"}
{"task_id": "HumanEval/13", "completion": "def greatest_common_divisor(a: int, b: int) -> int:\n    while a != b:\n        if a > b:\n            a -= b\n        else:\n            b -= a\n    return abs(a)"}
{"task_id": "HumanEval/14", "completion": "from typing import List\n\ndef all_prefixes(string: str) -> List[str]:\n    result = []\n    for i in range(len(string)+1):\n        result.append(string[:i])\n    return result"}
{"task_id": "HumanEval/15", "completion": "def string_sequence(n: int) -> str:\n    sequence = ' '.join(map(str, range(n+1)))\n    return sequence"}
{"task_id": "HumanEval/16", "completion": "def count_distinct_characters(string: str) -> int:\n    return len(set(string))"}
{"task_id": "HumanEval/17", "completion": "from typing import List\n\ndef parse_music(music_string: str) -> List[int]:\n    beats = []\n    for note in music_string:\n        if note == 'o':\n            beats.append(4)\n        elif note == 'o|':\n            beats.append(2)\n        elif note == '.|':\n            beats.append(1)\n    return beats"}
{"task_id": "HumanEval/18", "completion": "def how_many_times(string: str, substring: str) -> int:\n    count = 0\n    start = 0\n    while True:\n        start = string.find(substring, start)\n        if start == -1:\n            break\n        count += 1\n        start += len(substring)\n    return count"}
{"task_id": "HumanEval/19", "completion": " from typing import List\n\n                    def sort_numbers(numbers: str) -> str:\n                        numbers_list = numbers.split(' ')\n                        sorted_numbers = sorted(numbers_list, key=lambda x: int(x))\n                        return ' '.join(sorted_numbers)"}
{"task_id": "HumanEval/20", "completion": "from typing import List, Tuple\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    min_diff = float('inf')\n    closest_nums = None\n    for num1 in numbers:\n        for num2 in numbers:\n            if num1 != num2 and abs(num1 - num2) < min_diff:\n                min_diff = abs(num1 - num2)\n                closest_nums = (num1, num2)\n    return closest_nums"}
{"task_id": "HumanEval/21", "completion": "from typing import List\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n        such that the smallest number will become 0 and the largest will become 1\n    \"\"\"\n    if len(numbers) < 2:\n        raise ValueError(\"List should have at least two elements\")\n\n    min_value = min(numbers)\n    max_value = max(numbers)\n\n    return [(x - min_value) / (max_value - min_value) for x in numbers]"}
{"task_id": "HumanEval/22", "completion": "from typing import List, Any\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\"\n    return list(filter(lambda x: isinstance(x, int), values))"}
{"task_id": "HumanEval/23", "completion": "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    \"\"\"\n    return len(string)"}
{"task_id": "HumanEval/24", "completion": "\ndef largest_divisor(n: int):\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    \"\"\"\n    i = 1\n    while True:\n        if n % i == 0 and n // i != i:\n            return i\n        elif n % i != 0:\n            i += 1\n        else:\n            break\n    return n - 1"}
{"task_id": "HumanEval/25", "completion": "from typing import List\n\ndef factorize(n: int) -> List[int]:\n    i = 2\n    factors = []\n    while n % i != 0:\n        i += 1\n    factors.append(i)\n    n //= i\n    while n > 1:\n        i = 2\n        while n % i == 0:\n            factors.append(i)\n            n //= i\n    return factors"}
{"task_id": "HumanEval/26", "completion": " def remove_duplicates(numbers):\n                        return list(set(numbers))\n                        \n                    # or using dictionary to keep order:\n                    # def remove_duplicates(numbers):\n                    #     seen = set()\n                    #     return [x for x in numbers if not (x in seen or seen.add(x))]"}
{"task_id": "HumanEval/27", "completion": "def flip_case(string: str) -> str:\n    result = \"\"\n    for char in string:\n        if char.isupper():\n            result += char.lower()\n        else:\n            result += char.upper()\n    return result"}
{"task_id": "HumanEval/28", "completion": "from typing import List\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" Concatenate list of strings into a single string\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\"\n    return ''.join(strings)"}
{"task_id": "HumanEval/29", "completion": "from typing import List\n\ndef filter_by_prefix(strings: List[str], prefix: str) -> List[str]:\n    return [s for s in strings if s.startswith(prefix)]"}
{"task_id": "HumanEval/30", "completion": "def get_positive(l):\n    return [i for i in l if i > 0]"}
{"task_id": "HumanEval/31", "completion": "\n                    def is_prime(n):\n                        if n <= 1:\n                            return False\n                        for i in range(2, int(n**0.5)+1):\n                            if n % i == 0:\n                                return False\n                        return True"}
{"task_id": "HumanEval/32", "completion": "```python\n                    import math\n\n\n                    def poly(xs: list, x: float):\n                        \"\"\"\n                        Evaluates polynomial with coefficients xs at point x.\n                        return xs[0] + xs[1] * x + xs[1] * x**2 + .... xs[n] * x**n\n                        \"\"\"\n                        return sum([coeff * math.pow(x, i) for i, coeff in enumerate(xs)])\n\n\n                    def find_zero(xs: list):\n                        \"\"\" xs are coefficients of a polynomial.\n                        find_zero finds x such that poly(x) = 0.\n                        find_zero returns only one zero point, even if there are many.\n                        Moreover, find_zero only takes list xs having even number of coefficients\n                        and largest non zero coefficient as it guarantees a solution.\n                        \"\"\"\n                        n = len(xs) // 2\n                        coeff = xs[-1]\n                        if abs(coeff) < 1e-9:\n                            raise ValueError"}
{"task_id": "HumanEval/33", "completion": "\n                    def sort_third(l):\n                        indices = [i for i, x in enumerate(l) if i % 3 != 0]\n                        unchanged = [l[i] for i in indices]\n                        indices_sorted = [i for i in enumerate(l)[::3]]\n                        sorted_values = [l[i][0] for i in indices_sorted]\n                        return [unchanged[i] if i % 3 != 0 else sorted_values[int(i/3)] for i in range(len(l))]\n\n                    # Test cases:\n                    assert sort_third([1, 2, 3]) == [1, 2, 3], \"First test case failed\"\n                    assert sort_third([5, 6, 3, 4, 8, 9, 2]) == [2, 6, 3, 4, 8, 9, 5], \"Second test case failed\""}
{"task_id": "HumanEval/34", "completion": "\n                    def unique(l):\n                        return list(set(l))\n                        # or use a dictionary to keep only the first occurrence of each element and convert it back to list\n                        # return list(dict.fromkeys(l))"}
{"task_id": "HumanEval/35", "completion": "\ndef max_element(l):\n    return max(l)"}
{"task_id": "HumanEval/36", "completion": "\n                    def is_divisible(n, divisor):\n                        return n % divisor == 0\n\n                    count = 0\n                    for i in range(1, n):\n                        if (is_divisible(i, 11) or is_divisible(i, 13)):\n                            if int(str(i)[-1]) == 7:\n                                count += 1\n\n                    return count"}
{"task_id": "HumanEval/37", "completion": "\n                    def sort_even(l):\n                        even_indices = [i for i in range(len(l)) if i % 2 == 0]\n                        sorted_evens = [l[i] for i in even_indices]\n                        sorted_evens.sort()\n                        result = l[:]\n                        for i in even_indices:\n                            result[i] = sorted_evens[i - len(even_indices) // 2]\n                        return result\n\n                    # Test cases\n                    assert sort_even([1, 2, 3]) == [1, 2, 3]\n                    assert sort_even([5, 6, 3, 4]) == [3, 6, 5, 4]\n                    assert sort_even([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5]\n                    assert sort_even([7, 8, 9, 10, 11]) == [7, 8, 9, 10,"}
{"task_id": "HumanEval/38", "completion": "def encode_cyclic(s: str):\n    \"\"\"\n    returns encoded string by cycling groups of three characters.\n    \"\"\"\n    groups = [s[(3 * i):min((3 * i + 3), len(s))] for i in range((len(s) + 2) // 3)]\n    return \"\".join([(group[1:] + group[0]) if len(group) >= 3 else group for group in groups])\n\ndef decode_cyclic(s: str):\n    \"\"\"\n    takes as input string encoded with encode_cyclic function. Returns decoded string.\n    \"\"\"\n    n = len(s) // 3\n    return \"\".join([s[i:i+3] for i in range(0, len(s), 3*n)])"}
{"task_id": "HumanEval/39", "completion": "\n                    def is_prime(n):\n                        if n <= 1:\n                            return False\n                        for i in range(2, int(n ** 0.5) + 1):\n                            if n % i == 0:\n                                return False\n                        return True\n\n                    def fibonacci(n):\n                        a = b = 0\n                        for _ in range(n):\n                            a, b = b, a + b\n                        return a\n\n                    def prime_fib(n):\n                        i = 1\n                        while True:\n                            fib_num = fibonacci(i)\n                            if is_prime(fib_num):\n                                return fib_num\n                            i += 1\n\n                    ### End of code."}
{"task_id": "HumanEval/40", "completion": "\n                    def triples_sum_to_zero(l):\n                        if len(l) < 3:\n                            return False\n                        set_l = set(l) # convert list to set for O(1) time lookup\n                        for i in l:\n                            target = 0 - i\n                            if target in set_l and i != target: # check for distinct elements\n                                a, b = i, target\n                                while a == b:\n                                    b = next((x for x in set_l if x != i and x > b), None)\n                                return [i, a, b]\n                        return False"}
{"task_id": "HumanEval/41", "completion": "\n                    def car_race_collision(n):\n                        left_cars = [0] * (2*n) # Initialize list of length 2n for left cars positions\n                        right_cars = [n] * n # Initialize list of length n for right cars positions\n                        collisions = 0 # Initialize counter for collisions\n\n                        while True:\n                            for i in range(len(left_cars)-1):\n                                if left_cars[i] >= right_cars[-(i+1)]: # Check for collision\n                                    collisions += 1\n                                    break\n                                left_cars[i], left_cars[i+1] = left_cars[i+1], left_cars[i] # Swap positions to simulate cars moving\n                            else:\n                                break\n\n                            for i in range(len(right_cars)-1):\n                                right_cars[i], right_cars[i+1] = right_cars[i+1], right_cars[i"}
{"task_id": "HumanEval/42", "completion": "\n                    def incr_list(l):\n                        return [i + 1 for i in l]\n                    \n                    # or using list comprehension with enumerate:\n                    # def incr_list(l):\n                    #     return [i[0]+1 for i in enumerate(l)]"}
{"task_id": "HumanEval/43", "completion": "\n                    def pairs_sum_to_zero(l):\n                        set_numbers = set(l) # convert list to set for O(1) time lookup\n                        for num in l:\n                            if -num in set_numbers: # check if negative of current number is present in the set\n                                return True\n                        return False"}
{"task_id": "HumanEval/44", "completion": "\n                    def change_base(x, base):\n                        if x == 0:\n                            return ''\n                        digits = '0123456789ABCDEF'[:base]\n                        quotient, remainder = divmod(x, base)\n                        result = change_base(quotient, base) + digits[remainder]\n                        return result\n                        \n                    # Test cases:\n                    assert change_base(8, 3) == '22'\n                    assert change_base(8, 2) == '1000'\n                    assert change_base(7, 2) == '111'"}
{"task_id": "HumanEval/45", "completion": "def triangle_area(a, h):\n    \"\"\"Given length of a side and high return area for a triangle.\n    \"\"\"\n    area = 0.5 * a * h\n    return area"}
{"task_id": "HumanEval/46", "completion": "\n                    def fib4(n):\n                        if n < 0:\n                            raise ValueError(\"Input should be non-negative integer\")\n                        elif n <= 3:\n                            return 0\n                        else:\n                            a, b = 0, 2\n                            for _ in range(n - 2):\n                                c = a + b\n                                a, b = b, c\n                            return b\n\n                    # Test cases\n                    assert fib4(5) == 4\n                    assert fib4(6) == 8\n                    assert fib4(7) == 14"}
{"task_id": "HumanEval/47", "completion": "\n                    def median(l):\n                        l = sorted(l)\n                        n = len(l)\n                        if n % 2 == 0:\n                            return (l[n//2 - 1] + l[n//2]) / 2\n                        else:\n                            return l[n//2]\n\n                    # Test cases\n                    assert median([3, 1, 2, 4, 5]) == 3\n                    assert median([-10, 4, 6, 1000, 10, 20]) == 15.0"}
{"task_id": "HumanEval/48", "completion": "\n                    def is_palindrome(text: str):\n                        text = text.lower() # convert to lowercase for case insensitive comparison\n                        return text == text[::-1] # check if string is equal to its reverse\n\n                    # Test cases\n                    assert is_palindrome('') is True\n                    assert is_palindrome('aba') is True\n                    assert is_palindrome('aaaaa') is True\n                    assert is_palindrome('zbcd') is False"}
{"task_id": "HumanEval/49", "completion": "\n                    def power(base, exp, mod):\n                        result = 1\n                        while exp > 0:\n                            result = (result * base) % mod\n                            exp -= 1\n                        return result\n\n                    def modp(n, p):\n                        return power(2, n, p)\n\n                    # Test cases\n                    assert modp(3, 5) == 3\n                    assert modp(1101, 101) == 2\n                    assert modp(0, 101) == 1\n                    assert modp(3, 11) == 8\n                    assert modp(100, 101) == 1"}
{"task_id": "HumanEval/50", "completion": "\n                    def encode_shift(s):\n                        return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\n                        ### Response:\n                        def encode_shift(s):\n                            result = \"\"\n                            for char in s:\n                                new_char = chr((ord(char) + 5 - ord(\"a\") + 26) % 26 + ord(\"a\"))\n                                result += new_char\n                            return result\n\n\n                        ### Response:\n                        def encode_shift(s):\n                            encoded = \"\"\n                            for char in s:\n                                ascii_num = ord(char) + 5\n                                if ascii_num > ord(\"z\"):\n                                    ascii_num -= 26\n                                encoded += chr(ascii_num)\n                            return encoded\n\n\n                        ### Response:\n                        def encode_shift(s):\n                            result = \"\"\n                            for char in s:"}
{"task_id": "HumanEval/51", "completion": "\n                    def remove_vowels(text):\n                        vowels = \"aeiouAEIOU\"\n                        return ''.join([char for char in text if char not in vowels])"}
{"task_id": "HumanEval/52", "completion": "\n                    def below_threshold(l, t):\n                        return all([x < t for x in l])\n\n                    # Test cases:\n                    assert below_threshold([1, 2, 4, 10], 100) is True\n                    assert below_threshold([1, 20, 4, 10], 5) is False"}
{"task_id": "HumanEval/53", "completion": "def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\"\"\"\n    return x + y"}
{"task_id": "HumanEval/54", "completion": "\n                    def same_chars(s0, s1):\n                        set_s0 = set(s0)\n                        set_s1 = set(s1)\n                        return set_s0 == set_s1\n\n                    # or using frozenset instead of set for better performance\n                    # def same_chars(s0, s1):\n                    #     return frozenset(s0) == frozenset(s1)"}
{"task_id": "HumanEval/55", "completion": "\ndef fib(n):\n    if n <= 1:\n        return n\n    else:\n        return fib(n-1) + fib(n-2)"}
{"task_id": "HumanEval/56", "completion": "\n                    def correct_bracketing(brackets: str):\n                        stack = []\n                        opening_brackets = \"([{\"\n                        closing_brackets = \")]}\"\n                        for bracket in brackets:\n                            if bracket in opening_brackets:\n                                stack.append(bracket)\n                            elif bracket in closing_brackets and len(stack) > 0 and stack[-1] == opening_brackets[closing_brackets.index(bracket)]:\n                                stack.pop()\n                            else:\n                                return False\n                        return not bool(len(stack))\n\n                    # Test cases\n                    assert correct_bracketing(\"<\") == False\n                    assert correct_bracketing(\"<>\") == True\n                    assert correct_bracketing(\"<<><>>\") == True\n                    assert correct_bracketing(\"><<>\") == False"}
{"task_id": "HumanEval/57", "completion": "def monotonic(l):\n    if len(l) < 2:\n        return True\n    direction = l[0] > l[1]\n    for i in range(1, len(l)):\n        if direction ^ (l[i] > l[i-1]):\n            return False\n    return True"}
{"task_id": "HumanEval/58", "completion": "\n                    def common(l1, l2):\n                        set_l1 = set(l1)\n                        set_l2 = set(l2)\n                        common_set = set_l1.intersection(set_l2)\n                        return list(sorted(common_set))\n\n                    ### Test:\n                    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n                    [1, 5, 653]\n                    >>> common([5, 3, 2, 8], [3, 2])\n                    [2, 3]"}
{"task_id": "HumanEval/59", "completion": "\n                    def is_prime(num):\n                        \"\"\"Check if a number is prime\"\"\"\n                        if num < 2:\n                            return False\n                        for i in range(2, int(num ** 0.5) + 1):\n                            if num % i == 0:\n                                return False\n                        return True\n\n                    def largest_prime_factor(n):\n                        \"\"\"Return the largest prime factor of n\"\"\"\n                        while not is_prime(n):\n                            n -= 1\n                            while n % 2 == 0:\n                                n //= 2\n                        return n\n\n                    # Test cases\n                    assert largest_prime_factor(13195) == 29\n                    assert largest_prime_factor(2048) == 2"}
{"task_id": "HumanEval/60", "completion": "def sum_to_n(n):\n    total = 0\n    for i in range(1, n+1):\n        total += i\n    return total"}
{"task_id": "HumanEval/61", "completion": "\n                    def correct_bracketing(brackets: str):\n                        stack = []\n                        for bracket in brackets:\n                            if bracket == '(':\n                                stack.append(bracket)\n                            elif bracket == ')':\n                                if not stack or stack.pop() != '(':\n                                    return False\n                        return len(stack) == 0\n\n                    # Test cases:\n                    assert correct_bracketing(\"\") is True\n                    assert correct_bracketing(\"()\") is True\n                    assert correct_bracketing(\"(()())\") is True\n                    assert correct_bracketing(\")(()\") is False\n                    assert correct_bracketing(\"(())\") is True\n                    assert correct_bracketing(\")(\") is False\n                    assert correct_bracketing(\"((()))\") is True\n                    assert correct_bracketing(\")(\") is False\n                    assert correct_bracketing(\"()(\") is False\n                    assert correct_bracketing(\"(())((()))\") is True\n                   "}
{"task_id": "HumanEval/62", "completion": "def derivative(xs: list):\n    n = len(xs)\n    return [0] + [sum(map(lambda p, q: p * (q + 1), xs[i], xs[i+1])) for i in range(n-1)]"}
{"task_id": "HumanEval/63", "completion": ""}
{"task_id": "HumanEval/64", "completion": ""}
{"task_id": "HumanEval/65", "completion": ""}
{"task_id": "HumanEval/66", "completion": ""}
{"task_id": "HumanEval/67", "completion": ""}
{"task_id": "HumanEval/68", "completion": ""}
{"task_id": "HumanEval/69", "completion": ""}
{"task_id": "HumanEval/70", "completion": ""}
{"task_id": "HumanEval/71", "completion": ""}
{"task_id": "HumanEval/72", "completion": ""}
{"task_id": "HumanEval/73", "completion": ""}
{"task_id": "HumanEval/74", "completion": ""}
{"task_id": "HumanEval/75", "completion": ""}
{"task_id": "HumanEval/76", "completion": ""}
{"task_id": "HumanEval/77", "completion": ""}
{"task_id": "HumanEval/78", "completion": ""}
{"task_id": "HumanEval/79", "completion": ""}
{"task_id": "HumanEval/80", "completion": ""}
{"task_id": "HumanEval/81", "completion": ""}
{"task_id": "HumanEval/82", "completion": ""}
{"task_id": "HumanEval/83", "completion": ""}
{"task_id": "HumanEval/84", "completion": ""}
{"task_id": "HumanEval/85", "completion": ""}
{"task_id": "HumanEval/86", "completion": ""}
{"task_id": "HumanEval/87", "completion": ""}
{"task_id": "HumanEval/88", "completion": ""}
{"task_id": "HumanEval/89", "completion": ""}
{"task_id": "HumanEval/90", "completion": ""}
{"task_id": "HumanEval/91", "completion": ""}
{"task_id": "HumanEval/92", "completion": ""}
{"task_id": "HumanEval/93", "completion": ""}
{"task_id": "HumanEval/94", "completion": ""}
{"task_id": "HumanEval/95", "completion": ""}
{"task_id": "HumanEval/96", "completion": ""}
{"task_id": "HumanEval/97", "completion": ""}
{"task_id": "HumanEval/98", "completion": ""}
{"task_id": "HumanEval/99", "completion": ""}
{"task_id": "HumanEval/100", "completion": ""}
{"task_id": "HumanEval/101", "completion": ""}
{"task_id": "HumanEval/102", "completion": ""}
{"task_id": "HumanEval/103", "completion": ""}
{"task_id": "HumanEval/104", "completion": ""}
{"task_id": "HumanEval/105", "completion": ""}
{"task_id": "HumanEval/106", "completion": ""}
{"task_id": "HumanEval/107", "completion": ""}
{"task_id": "HumanEval/108", "completion": ""}
{"task_id": "HumanEval/109", "completion": ""}
{"task_id": "HumanEval/110", "completion": ""}
{"task_id": "HumanEval/111", "completion": ""}
{"task_id": "HumanEval/112", "completion": ""}
{"task_id": "HumanEval/113", "completion": ""}
{"task_id": "HumanEval/114", "completion": ""}
{"task_id": "HumanEval/115", "completion": ""}
{"task_id": "HumanEval/116", "completion": ""}
{"task_id": "HumanEval/117", "completion": ""}
{"task_id": "HumanEval/118", "completion": ""}
{"task_id": "HumanEval/119", "completion": ""}
{"task_id": "HumanEval/120", "completion": ""}
{"task_id": "HumanEval/121", "completion": ""}
{"task_id": "HumanEval/122", "completion": ""}
{"task_id": "HumanEval/123", "completion": ""}
{"task_id": "HumanEval/124", "completion": ""}
{"task_id": "HumanEval/125", "completion": ""}
{"task_id": "HumanEval/126", "completion": ""}
{"task_id": "HumanEval/127", "completion": ""}
{"task_id": "HumanEval/128", "completion": ""}
{"task_id": "HumanEval/129", "completion": ""}
{"task_id": "HumanEval/130", "completion": ""}
{"task_id": "HumanEval/131", "completion": ""}
{"task_id": "HumanEval/132", "completion": ""}
{"task_id": "HumanEval/133", "completion": ""}
{"task_id": "HumanEval/134", "completion": ""}
{"task_id": "HumanEval/135", "completion": ""}
{"task_id": "HumanEval/136", "completion": ""}
{"task_id": "HumanEval/137", "completion": ""}
{"task_id": "HumanEval/138", "completion": ""}
{"task_id": "HumanEval/139", "completion": ""}
{"task_id": "HumanEval/140", "completion": ""}
{"task_id": "HumanEval/141", "completion": ""}
{"task_id": "HumanEval/142", "completion": ""}
{"task_id": "HumanEval/143", "completion": ""}
{"task_id": "HumanEval/144", "completion": ""}
{"task_id": "HumanEval/145", "completion": ""}
{"task_id": "HumanEval/146", "completion": ""}
{"task_id": "HumanEval/147", "completion": ""}
{"task_id": "HumanEval/148", "completion": ""}
{"task_id": "HumanEval/149", "completion": ""}
{"task_id": "HumanEval/150", "completion": ""}
{"task_id": "HumanEval/151", "completion": ""}
{"task_id": "HumanEval/152", "completion": ""}
{"task_id": "HumanEval/153", "completion": ""}
{"task_id": "HumanEval/154", "completion": ""}
{"task_id": "HumanEval/155", "completion": ""}
{"task_id": "HumanEval/156", "completion": ""}
{"task_id": "HumanEval/157", "completion": ""}
{"task_id": "HumanEval/158", "completion": ""}
{"task_id": "HumanEval/159", "completion": ""}
{"task_id": "HumanEval/160", "completion": ""}
{"task_id": "HumanEval/161", "completion": ""}
{"task_id": "HumanEval/162", "completion": ""}
{"task_id": "HumanEval/163", "completion": ""}
